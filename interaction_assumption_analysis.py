#!/usr/bin/env python3
"""
交互项假设检验深度分析报告
解释为什么交互项在高级建模中表现良好，但在诊断中表现不佳
"""

def interaction_assumption_analysis():
    """分析交互项的假设检验问题"""
    
    print("🤔 交互项假设检验深度分析")
    print("="*80)
    
    print("""
📊 **观察到的现象：**
1. 高级建模中：交互模型 C-index = 0.8301，表现优秀
2. 诊断建模中：交互模型 C-index = 0.7747，表现下降
3. AIC变差：基础模型更简洁
4. 似然比检验：交互项改善不显著

🔍 **可能的原因分析：**
""")
    
    reasons = {
        "1. 数据准备差异": {
            "问题": "高级建模和诊断建模使用了不同的数据预处理流程",
            "影响": "样本数量、特征工程、数据清洗标准不同",
            "证据": "观测数量差异：高级(18,691) vs 诊断(19,667)"
        },
        
        "2. 正则化效应": {
            "问题": "诊断模型使用了更强的正则化(penalizer=0.05)",
            "影响": "抑制了交互项的复杂效应，导致性能下降",
            "证据": "基础模型用0.01，交互模型用0.05"
        },
        
        "3. 过拟合vs泛化": {
            "问题": "高级建模可能存在过拟合，诊断建模更保守",
            "影响": "交互项在训练集表现好，但泛化能力有限",
            "证据": "AIC增加285.28，模型复杂度惩罚"
        },
        
        "4. 交互项质量": {
            "问题": "并非所有44个交互项都有实际意义",
            "影响": "噪声交互项稀释了真正有用的交互效应",
            "证据": "只有15/44个交互项显著"
        },
        
        "5. Cox假设的层次性": {
            "问题": "交互项创造了更复杂的假设检验情况",
            "影响": "基础假设可能在交互层面被违反",
            "证据": "比例风险假设检验结果不一致"
        }
    }
    
    for reason, details in reasons.items():
        print(f"\n**{reason}:**")
        print(f"   问题: {details['问题']}")
        print(f"   影响: {details['影响']}")
        print(f"   证据: {details['证据']}")
    
    print(f"""
🎯 **Cox回归交互项的假设要求：**

✅ **交互项需要满足的假设：**
1. **比例风险假设**: 交互项的效应也应该随时间保持恒定
2. **线性假设**: 交互项与对数风险比呈线性关系
3. **独立性假设**: 交互项之间不应高度相关
4. **稳定性假设**: 交互效应在不同子群中保持一致

❌ **交互项容易违反假设的情况：**
1. **时间依赖交互**: 模型A在早期敏感，模型B在后期敏感
2. **非线性交互**: 交互效应存在阈值或饱和点
3. **多重共线性**: 多个交互项高度相关
4. **稀疏交互**: 某些模型组合很少出现

🔬 **当前发现的问题：**
""")
    
    findings = {
        "假设检验矛盾": "Schoenfeld残差显示0违反，但模型性能下降",
        "性能退化": "C-index从0.8301降至0.7747 (-6.7%)",
        "复杂度惩罚": "AIC增加285.28，模型过度复杂",
        "统计不显著": "似然比检验p=1.0，交互项无统计意义"
    }
    
    for finding, description in findings.items():
        print(f"   • **{finding}**: {description}")
    
    print(f"""
💡 **建议的解决方案：**

**1. 选择性交互建模:**
```python
# 只包含显著的交互项
significant_interactions = [
    'prompt_to_prompt_drift_x_model_mistral_large',  # HR=5.72e+15
    'prompt_to_prompt_drift_x_model_qwen_max',       # HR=2.52e+14
    'prompt_to_prompt_drift_x_model_deepseek_r1'     # HR=3.02e+10
]
```

**2. 分层建模策略:**
```python
# 先验证主效应，再添加交互项
model_hierarchy = [
    '基础模型: drift + model',
    '一阶交互: + drift*model', 
    '时间交互: + drift*model*time'
]
```

**3. 交叉验证:**
```python
# 用交叉验证评估真实性能
from sklearn.model_selection import KFold
cv_scores = cross_validate_cox_model(interactions=True)
```

**4. 假设检验分层:**
```python
# 分别检验不同层次的假设
test_main_effects()      # 主效应假设
test_interactions()      # 交互效应假设  
test_time_varying()      # 时间变化假设
```

🏆 **最终建议：**

对于LLM生存分析，建议采用**混合策略**：

1. **基础模型**用于理解主要效应和假设检验
2. **精选交互模型**用于提升预测性能
3. **时间分层模型**用于处理假设违反
4. **集成方法**结合多个模型的优势

关键是要在**统计严谨性**和**预测性能**之间找到平衡！
""")

if __name__ == "__main__":
    interaction_assumption_analysis()